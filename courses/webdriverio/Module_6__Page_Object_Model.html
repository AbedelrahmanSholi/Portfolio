<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" href="../../css/courses/comprehensive_course_styling.css">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 6: Page Object Model Implementation</title>
    <link rel="stylesheet" href="../../css/courses/enhanced_course_styling.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/atom-one-dark.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@9/dist/mermaid.min.js"></script>
    <script src="../../js/courses/mermaid_loader.js"></script>
</head>

<body>
    <div class="course-content-wrapper">
        <div class="module-navigation">
            <a href="Module_5__API_Testing_with_WebDriverIO.html" class="nav-btn prev-btn">
                <i class="fas fa-chevron-left"></i> Previous: API Testing with WebDriverIO
            </a>
            <a href="Module_7__WebDriverIO_with_Cucumber_Integration.html" class="nav-btn next-btn">
                Next: WebDriverIO with Cucumber Integration <i class="fas fa-chevron-right"></i>
            </a>
        </div>

        <h1 id="module-6-page-object-model-implementation">Module 6: Page Object Model Implementation</h1>

<h2 id="learning-objectives">Learning Objectives</h2>

<ul>
<li>Understand the principles and benefits of the Page Object Model</li>
<li>Implement page objects in WebDriverIO with Java</li>
<li>Structure your test framework using the Page Object Model</li>
<li>Apply best practices for maintainable page objects</li>
<li>Extend the basic Page Object Model with advanced patterns</li>
</ul>

<h2 id="61-introduction-to-page-object-model">6.1 Introduction to Page Object Model</h2>

<h3 id="what-is-the-page-object-model">What is the Page Object Model?</h3>

<p>The Page Object Model (POM) is a design pattern that creates an abstraction of the UI page with which the tests interact. Each web page in the application is represented by a corresponding page class. The page class contains:</p>

<ol>
<li><strong>Element locators</strong>: Selectors for the UI elements on the page</li>
<li><strong>Methods</strong>: Actions that can be performed on the page</li>
<li><strong>Verification points</strong>: Assertions about the page state</li>
</ol>

<h3 id="benefits-of-the-page-object-model">Benefits of the Page Object Model</h3>

<table>
<thead>
<tr>
  <th>Benefit</th>
  <th>Description</th>
  <th>Example</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>Reduced Duplication</strong></td>
  <td>Element locators are defined once</td>
  <td>Instead of repeating <code>$("#login-button")</code> in multiple tests, define it once in the LoginPage class</td>
</tr>
<tr>
  <td><strong>Improved Maintenance</strong></td>
  <td>When the UI changes, only the page object needs to be updated</td>
  <td>If the login button ID changes, update only the LoginPage class, not all tests</td>
</tr>
<tr>
  <td><strong>Better Readability</strong></td>
  <td>Tests express intent rather than implementation details</td>
  <td><code>loginPage.login(username, password)</code> vs. complex element interactions</td>
</tr>
<tr>
  <td><strong>Enhanced Reusability</strong></td>
  <td>Page objects can be used across multiple tests</td>
  <td>The same LoginPage can be used in authentication tests, security tests, etc.</td>
</tr>
<tr>
  <td><strong>Separation of Concerns</strong></td>
  <td>Test logic is separated from page interactions</td>
  <td>Tests focus on business scenarios while page objects handle UI interactions</td>
</tr>
</tbody>
</table>

<h3 id="traditional-approach-vs-page-object-model">Traditional Approach vs. Page Object Model</h3>

<p><strong>Traditional Approach:</strong></p>

<pre><code>@Test
public void testLogin() {
    browser.url("https://example.com/login");

    browser.findElement("#username").setValue("testuser");
    browser.findElement("#password").setValue("password");
    browser.findElement("#login-button").click();

    boolean isDashboardVisible = browser.findElement(".dashboard").isDisplayed();
    assertTrue(isDashboardVisible);
}

@Test
public void testInvalidLogin() {
    browser.url("https://example.com/login");

    browser.findElement("#username").setValue("testuser");
    browser.findElement("#password").setValue("wrongpassword");
    browser.findElement("#login-button").click();

    boolean isErrorVisible = browser.findElement(".error-message").isDisplayed();
    assertTrue(isErrorVisible);
}
</code></pre>

<p><strong>Page Object Model Approach:</strong></p>

<pre><code>@Test
public void testLogin() {
    LoginPage loginPage = new LoginPage(browser);
    loginPage.open();

    DashboardPage dashboardPage = loginPage.login("testuser", "password");
    assertTrue(dashboardPage.isDisplayed());
}

@Test
public void testInvalidLogin() {
    LoginPage loginPage = new LoginPage(browser);
    loginPage.open();

    loginPage.loginExpectingError("testuser", "wrongpassword");
    assertTrue(loginPage.isErrorMessageDisplayed());
}
</code></pre>

<h2 id="62-implementing-page-objects-in-webdriverio-with-java">6.2 Implementing Page Objects in WebDriverIO with Java</h2>

<h3 id="page-object-model-structure">Page Object Model Structure</h3>

<p><iframe sandbox="allow-scripts allow-same-origin" src="../resources/diagrams/page_object_model.html" width="100%" height="500px" frameborder="0"></iframe></p>

<h3 id="page-object-interaction-flow">Page Object Interaction Flow</h3>

<p><iframe sandbox="allow-scripts allow-same-origin" src="../resources/diagrams/page_object_interaction.html" width="100%" height="500px" frameborder="0"></iframe></p>

<pre><code>public class BasePage {
    protected WebDriverIO browser;

    public BasePage(WebDriverIO browser) {
        this.browser = browser;
    }

    // Common methods for all pages
    public String getPageTitle() {
        return browser.getTitle();
    }

    public void waitForPageLoad() {
        browser.waitUntil(() -&gt; 
            browser.executeScript("return document.readyState").equals("complete"),
            10000,
            "Page did not load completely after 10 seconds"
        );
    }
}

public class LoginPage extends BasePage {
    // Element locators
    private static final String USERNAME_INPUT = "#username";
    private static final String PASSWORD_INPUT = "#password";
    private static final String LOGIN_BUTTON = "#login-button";
    private static final String ERROR_MESSAGE = ".error-message";

    public LoginPage(WebDriverIO browser) {
        super(browser);
    }

    public void open() {
        browser.url("https://example.com/login");
        waitForPageLoad();
    }

    public DashboardPage login(String username, String password) {
        enterUsername(username);
        enterPassword(password);
        clickLoginButton();

        // Return the next page object
        return new DashboardPage(browser);
    }

    public void loginExpectingError(String username, String password) {
        enterUsername(username);
        enterPassword(password);
        clickLoginButton();

        // Stay on the same page, expecting an error
    }

    public void enterUsername(String username) {
        browser.findElement(USERNAME_INPUT).setValue(username);
    }

    public void enterPassword(String password) {
        browser.findElement(PASSWORD_INPUT).setValue(password);
    }

    public void clickLoginButton() {
        browser.findElement(LOGIN_BUTTON).click();
    }

    public boolean isErrorMessageDisplayed() {
        return browser.findElement(ERROR_MESSAGE).isDisplayed();
    }

    public String getErrorMessage() {
        return browser.findElement(ERROR_MESSAGE).getText();
    }
}

public class DashboardPage extends BasePage {
    // Element locators
    private static final String DASHBOARD_CONTAINER = ".dashboard";
    private static final String WELCOME_MESSAGE = ".welcome-message";
    private static final String LOGOUT_BUTTON = "#logout";

    public DashboardPage(WebDriverIO browser) {
        super(browser);
        waitForPageLoad();
    }

    public boolean isDisplayed() {
        return browser.findElement(DASHBOARD_CONTAINER).isDisplayed();
    }

    public String getWelcomeMessage() {
        return browser.findElement(WELCOME_MESSAGE).getText();
    }

    public LoginPage logout() {
        browser.findElement(LOGOUT_BUTTON).click();
        return new LoginPage(browser);
    }
}
</code></pre>

<h3 id="using-page-objects-in-tests">Using Page Objects in Tests</h3>

<pre><code>public class BaseTest {
    protected WebDriverIO browser;

    @BeforeMethod
    public void setup() {
        Options options = new Options();
        options.setBrowser("chrome");
        browser = new WebDriverIO(options);
    }

    @AfterMethod
    public void teardown() {
        if (browser != null) {
            browser.deleteSession();
        }
    }
}

public class LoginTest extends BaseTest {
    private LoginPage loginPage;

    @BeforeMethod
    public void setupLoginPage() {
        loginPage = new LoginPage(browser);
        loginPage.open();
    }

    @Test
    public void testSuccessfulLogin() {
        DashboardPage dashboardPage = loginPage.login("testuser", "password");

        assertTrue(dashboardPage.isDisplayed());
        assertEquals("Welcome, Test User!", dashboardPage.getWelcomeMessage());
    }

    @Test
    public void testInvalidPassword() {
        loginPage.loginExpectingError("testuser", "wrongpassword");

        assertTrue(loginPage.isErrorMessageDisplayed());
        assertEquals("Invalid username or password", loginPage.getErrorMessage());
    }

    @Test
    public void testEmptyUsername() {
        loginPage.loginExpectingError("", "password");

        assertTrue(loginPage.isErrorMessageDisplayed());
        assertEquals("Username is required", loginPage.getErrorMessage());
    }
}
</code></pre>

<h2 id="63-advanced-page-object-patterns">6.3 Advanced Page Object Patterns</h2>

<h3 id="page-factory-pattern">Page Factory Pattern</h3>

<p>The Page Factory pattern uses annotations to initialize page elements, reducing boilerplate code.</p>

<pre><code>public class LoginPage extends BasePage {
    @FindBy(css = "#username")
    private WebElement usernameInput;

    @FindBy(css = "#password")
    private WebElement passwordInput;

    @FindBy(css = "#login-button")
    private WebElement loginButton;

    @FindBy(css = ".error-message")
    private WebElement errorMessage;

    public LoginPage(WebDriverIO browser) {
        super(browser);
        PageFactory.initElements(browser, this);
    }

    // Methods using the initialized elements
    public void enterUsername(String username) {
        usernameInput.setValue(username);
    }

    // Other methods...
}
</code></pre>

<h3 id="fluent-page-objects">Fluent Page Objects</h3>

<p>Fluent page objects use method chaining for more readable test code.</p>

<pre><code>public class LoginPage extends BasePage {
    // Element locators and constructor...

    public LoginPage enterUsername(String username) {
        browser.findElement(USERNAME_INPUT).setValue(username);
        return this;
    }

    public LoginPage enterPassword(String password) {
        browser.findElement(PASSWORD_INPUT).setValue(password);
        return this;
    }

    public DashboardPage clickLoginButton() {
        browser.findElement(LOGIN_BUTTON).click();
        return new DashboardPage(browser);
    }

    // Usage in test
    // dashboardPage = loginPage.enterUsername("user").enterPassword("pass").clickLoginButton();
}
</code></pre>

<h3 id="component-objects">Component Objects</h3>

<p>Component objects represent reusable UI components that appear on multiple pages.</p>

<pre><code>public class HeaderComponent {
    private WebDriverIO browser;
    private String rootSelector;

    public HeaderComponent(WebDriverIO browser, String rootSelector) {
        this.browser = browser;
        this.rootSelector = rootSelector;
    }

    public void clickLogo() {
        browser.findElement(rootSelector + " .logo").click();
    }

    public void openUserMenu() {
        browser.findElement(rootSelector + " .user-menu").click();
    }

    public void search(String query) {
        browser.findElement(rootSelector + " .search-input").setValue(query);
        browser.findElement(rootSelector + " .search-button").click();
    }
}

public class BasePage {
    protected WebDriverIO browser;
    protected HeaderComponent header;

    public BasePage(WebDriverIO browser) {
        this.browser = browser;
        this.header = new HeaderComponent(browser, "header");
    }

    // Common methods...
}
</code></pre>

<h3 id="loadable-component-pattern">Loadable Component Pattern</h3>

<p>The Loadable Component pattern ensures a page is fully loaded before interacting with it.</p>

<pre><code>public abstract class LoadablePage&lt;T extends LoadablePage&lt;T&gt;&gt; {
    protected WebDriverIO browser;

    public LoadablePage(WebDriverIO browser) {
        this.browser = browser;
    }

    /**
     * Navigate to the page
     */
    public abstract T open();

    /**
     * Check if the page is loaded
     */
    public abstract boolean isLoaded();

    /**
     * Wait until the page is loaded
     */
    public T waitUntilLoaded() {
        browser.waitUntil(this::isLoaded, 10000, "Page did not load in 10 seconds");
        return (T) this;
    }

    /**
     * Open the page and wait until it's loaded
     */
    public T openAndWait() {
        return open().waitUntilLoaded();
    }
}

public class LoginPage extends LoadablePage&lt;LoginPage&gt; {
    private static final String URL = "https://example.com/login";
    private static final String USERNAME_INPUT = "#username";

    public LoginPage(WebDriverIO browser) {
        super(browser);
    }

    @Override
    public LoginPage open() {
        browser.url(URL);
        return this;
    }

    @Override
    public boolean isLoaded() {
        try {
            return browser.getUrl().contains("/login") &amp;&amp; 
                   browser.findElement(USERNAME_INPUT).isDisplayed();
        } catch (Exception e) {
            return false;
        }
    }

    // Other methods...
}
</code></pre>

<h2 id="64-best-practices-for-page-objects">6.4 Best Practices for Page Objects</h2>

<h3 id="1-keep-page-objects-focused">1. Keep Page Objects Focused</h3>

<p>Each page object should represent a single page or component with a clear responsibility.</p>

<p><strong>Good Practice:</strong></p>

<pre><code>// Separate page objects for different pages
public class LoginPage extends BasePage { /* ... */ }
public class DashboardPage extends BasePage { /* ... */ }
public class ProfilePage extends BasePage { /* ... */ }
</code></pre>

<p><strong>Bad Practice:</strong></p>

<pre><code>// One page object handling multiple pages
public class ApplicationPage extends BasePage {
    public void login(String username, String password) { /* ... */ }
    public void viewDashboard() { /* ... */ }
    public void editProfile(String name, String email) { /* ... */ }
}
</code></pre>

<h3 id="2-use-stable-selectors">2. Use Stable Selectors</h3>

<p>Choose selectors that are less likely to change with UI updates.</p>

<p><strong>Good Practice:</strong></p>

<pre><code>// Using data attributes or IDs
private static final String LOGIN_BUTTON = "[data-test-id='login-button']";
private static final String USERNAME_INPUT = "#username";
</code></pre>

<p><strong>Bad Practice:</strong></p>

<pre><code>// Using brittle selectors based on structure or styling
private static final String LOGIN_BUTTON = "form &gt; div:nth-child(3) &gt; button.btn-primary";
private static final String USERNAME_INPUT = "input.form-control:first-child";
</code></pre>

<h3 id="3-encapsulate-element-interactions">3. Encapsulate Element Interactions</h3>

<p>Hide the details of element interactions behind meaningful methods.</p>

<p><strong>Good Practice:</strong></p>

<pre><code>// Methods express intent
public void login(String username, String password) {
    enterUsername(username);
    enterPassword(password);
    clickLoginButton();
}
</code></pre>

<p><strong>Bad Practice:</strong></p>

<pre><code>// Exposing element interactions directly
public WebElement getUsernameInput() {
    return browser.findElement(USERNAME_INPUT);
}

public WebElement getPasswordInput() {
    return browser.findElement(PASSWORD_INPUT);
}

public WebElement getLoginButton() {
    return browser.findElement(LOGIN_BUTTON);
}
</code></pre>

<h3 id="4-return-page-objects-for-navigation">4. Return Page Objects for Navigation</h3>

<p>When an action navigates to a new page, return the corresponding page object.</p>

<p><strong>Good Practice:</strong></p>

<pre><code>public DashboardPage login(String username, String password) {
    enterUsername(username);
    enterPassword(password);
    clickLoginButton();
    return new DashboardPage(browser);
}
</code></pre>

<p><strong>Bad Practice:</strong></p>

<pre><code>public void login(String username, String password) {
    enterUsername(username);
    enterPassword(password);
    clickLoginButton();
    // No return value, caller doesn't know what page we're on
}
</code></pre>

<h3 id="5-include-verification-points">5. Include Verification Points</h3>

<p>Add methods to verify the state of the page.</p>

<p><strong>Good Practice:</strong></p>

<pre><code>public boolean isErrorMessageDisplayed() {
    return browser.findElement(ERROR_MESSAGE).isDisplayed();
}

public String getErrorMessage() {
    return browser.findElement(ERROR_MESSAGE).getText();
}
</code></pre>

<p><strong>Bad Practice:</strong></p>

<pre><code>// No verification methods, tests must access elements directly
// Test: browser.findElement(".error-message").isDisplayed()
</code></pre>

<h3 id="6-handle-waits-within-page-objects">6. Handle Waits Within Page Objects</h3>

<p>Encapsulate wait logic within the page object methods.</p>

<p><strong>Good Practice:</strong></p>

<pre><code>public DashboardPage login(String username, String password) {
    enterUsername(username);
    enterPassword(password);
    clickLoginButton();

    // Wait for navigation to complete
    browser.waitUntil(() -&gt; 
        browser.getUrl().contains("/dashboard"), 
        5000, 
        "Navigation to dashboard failed"
    );

    return new DashboardPage(browser);
}
</code></pre>

<p><strong>Bad Practice:</strong></p>

<pre><code>public void login(String username, String password) {
    enterUsername(username);
    enterPassword(password);
    clickLoginButton();
    // No waiting, test might fail if navigation is slow
}
</code></pre>

<h2 id="65-testing-page-objects">6.5 Testing Page Objects</h2>

<p>Page objects should be tested to ensure they work correctly.</p>

<h3 id="unit-testing-page-objects">Unit Testing Page Objects</h3>

<pre><code>public class LoginPageTest {
    private WebDriverIO browser;
    private LoginPage loginPage;

    @BeforeMethod
    public void setup() {
        // Setup browser and page
        Options options = new Options();
        options.setBrowser("chrome");
        browser = new WebDriverIO(options);
        loginPage = new LoginPage(browser);
    }

    @Test
    public void testPageElements() {
        loginPage.open();

        // Verify all required elements are present
        assertTrue(browser.findElement("#username").isDisplayed());
        assertTrue(browser.findElement("#password").isDisplayed());
        assertTrue(browser.findElement("#login-button").isDisplayed());
    }

    @Test
    public void testEnterUsername() {
        loginPage.open();

        // Test the enterUsername method
        loginPage.enterUsername("testuser");

        // Verify the username was entered
        assertEquals("testuser", browser.findElement("#username").getValue());
    }

    // More tests for other methods...

    @AfterMethod
    public void teardown() {
        if (browser != null) {
            browser.deleteSession();
        }
    }
}
</code></pre>

<h3 id="integration-testing-page-objects">Integration Testing Page Objects</h3>

<pre><code>public class PageObjectIntegrationTest {
    private WebDriverIO browser;

    @BeforeMethod
    public void setup() {
        Options options = new Options();
        options.setBrowser("chrome");
        browser = new WebDriverIO(options);
    }

    @Test
    public void testPageNavigation() {
        // Test navigation between pages
        LoginPage loginPage = new LoginPage(browser);
        loginPage.open();

        DashboardPage dashboardPage = loginPage.login("testuser", "password");
        assertTrue(dashboardPage.isDisplayed());

        ProfilePage profilePage = dashboardPage.navigateToProfile();
        assertTrue(profilePage.isDisplayed());

        dashboardPage = profilePage.navigateToDashboard();
        assertTrue(dashboardPage.isDisplayed());
    }

    @AfterMethod
    public void teardown() {
        if (browser != null) {
            browser.deleteSession();
        }
    }
}
</code></pre>

<h2 id="knowledge-checkpoint">Knowledge Checkpoint</h2>

<ul>
<li>[ ] Explain the key benefits of using the Page Object Model in test automation</li>
<li>[ ] Implement a basic page object for a login page with WebDriverIO and Java</li>
<li>[ ] Describe the difference between traditional test automation and the Page Object Model approach</li>
<li>[ ] Apply at least three best practices for creating maintainable page objects</li>
<li>[ ] Implement an advanced page object pattern such as Fluent Page Objects or Component Objects</li>
</ul>

<h2 id="practical-exercise">Practical Exercise</h2>

<h3 id="exercise-1-basic-page-object-implementation">Exercise 1: Basic Page Object Implementation</h3>

<ol>
<li>Create a new Java project with WebDriverIO and TestNG</li>
<li>Implement the following page objects:
<ul>
<li>BasePage with common methods</li>
<li>LoginPage with methods for authentication</li>
<li>DashboardPage with methods for dashboard interactions</li>
</ul></li>
<li>Write tests that use these page objects to:
<ul>
<li>Test successful login</li>
<li>Test failed login with invalid credentials</li>
<li>Test navigation between pages</li>
</ul></li>
<li>Run the tests and verify they pass</li>
</ol>

<h3 id="exercise-2-advanced-page-object-patterns">Exercise 2: Advanced Page Object Patterns</h3>

<ol>
<li>Extend your project to implement:
<ul>
<li>A HeaderComponent that can be used across multiple pages</li>
<li>Fluent page objects with method chaining</li>
<li>The Loadable Component pattern for at least one page</li>
</ul></li>
<li>Refactor your tests to use these advanced patterns</li>
<li>Add tests for edge cases:
<ul>
<li>Timeout handling</li>
<li>Error states</li>
<li>Dynamic content loading</li>
</ul></li>
<li>Run the tests and verify they pass</li>
</ol>

<h2 id="further-reading">Further Reading</h2>

<ul>
<li><a href="https://martinfowler.com/bliki/PageObject.html">Martin Fowler: Page Object Pattern</a></li>
<li><a href="https://webdriver.io/docs/pageobjects">WebDriverIO Page Objects Documentation</a></li>
<li><a href="https://www.selenium.dev/documentation/en/guidelines_and_recommendations/page_object_models/">Selenium Page Object Model</a></li>
<li><a href="https://www.pluralsight.com/guides/design-patterns-in-test-automation">Design Patterns in Test Automation</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Cross_browser_testing/Your_own_automation_environment">Testing Web Applications with Page Objects</a></li>
</ul>

<h2 id="next-steps">Next Steps</h2>

<p>In the next module, we'll explore WebDriverIO with Cucumber integration, learning how to combine the power of behavior-driven development with the Page Object Model for even more maintainable and business-focused test automation.</p>

<p><a href="Module_7__WebDriverIO_with_Cucumber_Integration.html">Continue to Module 7: WebDriverIO with Cucumber Integration</a></p>


    </div>

    <script>
        // Initialize syntax highlighting
        hljs.highlightAll();
        
        // Initialize Mermaid diagrams
        mermaid.initialize({ 
            theme: 'dark',
            startOnLoad: true 
        });
    </script>
</body>
</html>

