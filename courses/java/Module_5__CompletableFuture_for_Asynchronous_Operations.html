<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Security Meta Tags -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://unpkg.com; style-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com https://cdnjs.cloudflare.com; img-src 'self' data: https:; connect-src 'self'; frame-ancestors 'none'; base-uri 'self'; form-action 'self';">
    <meta http-equiv="X-Frame-Options" content="DENY">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta http-equiv="Referrer-Policy" content="strict-origin-when-cross-origin">
    <meta http-equiv="Permissions-Policy" content="geolocation=(), microphone=(), camera=(), payment=(), usb=(), magnetometer=(), gyroscope=(), speaker=()">

    <link rel="stylesheet" href="../../css/courses/comprehensive_course_styling.css">
    <link rel="stylesheet" href="../../css/optimized/main.min.css">
    <link rel="stylesheet" href="../../css/optimized/courses.min.css">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 5: CompletableFuture for Asynchronous Operations</title>
    <!-- Base styles -->
    <link href="/css/general_root.css" rel="stylesheet" />
    <link href="/css/background_effect.css" rel="stylesheet" />
    
    <!-- Consolidated hover and z-index styles - loaded early to establish hierarchy -->
    <link href="/css/z_index_system.css" rel="stylesheet" />
    <link href="/css/hover_fix_comprehensive.css" rel="stylesheet" />
    <link href="/css/tooltip_hover.css" rel="stylesheet" />
    
    <!-- Component styles -->
    <link href="/css/slider.css" rel="stylesheet" />
    <link href="/css/enhanced_components.css" rel="stylesheet" />
    <link href="/css/skills_alternative.css" rel="stylesheet" />
    <link href="/css/timeline.css" rel="stylesheet" />
    <link href="/css/project_showcase_fixed.css" rel="stylesheet" />
    <link href="/css/technical_skills_fixed.css" rel="stylesheet" />
    
    <!-- Fixes and enhancements -->
    <link href="/css/mobile_responsive.css" rel="stylesheet" />
    <link href="/css/design_fixes.css" rel="stylesheet" />
    <link href="/css/skills_icons_fix.css" rel="stylesheet" />
    <link href="/css/layout_fixes.css" rel="stylesheet" />
    <link href="/css/contact_fix.css" rel="stylesheet" />
    <link href="/css/final_fixes.css" rel="stylesheet" />
    
    <!-- External resources -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css" integrity="sha512-1ycn6IcaQQ40/MKBW2W4Rhis/DbILU74C1vSrLJxCq57o941Ym01SwNsOMqvEBFlcgUa6xLiPY/NS5R+E6ztJQ==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    
    <!-- Courses section styles -->
    <link href="/css/courses/courses.css" rel="stylesheet" />
    <link href="/css/courses/enhanced_course_styling.css" rel="stylesheet" />
    
    <!-- Syntax highlighting for code blocks -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/styles/atom-one-dark.min.css">

    <script src="../../js/courses/diagram_loader.js"></script></head>

<body>
    <div class="course-content-wrapper">
        <div class="module-navigation">
            <a href="Module_4__Optional_Class_for_Null_Handling.html" class="nav-btn prev-btn">
                <i class="fas fa-chevron-left"></i> Previous: Optional Class for Null Handling
            </a>
            <a href="Module_6__Reflection_API_for_Dynamic_Test_Frameworks.html" class="nav-btn next-btn">
                Next: Reflection API for Dynamic Test Frameworks <i class="fas fa-chevron-right"></i>
            </a>
        </div>

        <h1 id="module-5-completablefuture-for-asynchronous-operations">Module 5: CompletableFuture for Asynchronous Operations</h1>

        <h2 id="overview">Overview</h2>
        <p>CompletableFuture, introduced in Java 8, provides a powerful framework for asynchronous programming. In test automation, asynchronous operations are common when dealing with web services, UI interactions, and parallel test execution. This module explores how to leverage CompletableFuture to create more efficient, responsive, and maintainable test automation solutions.</p>

        <h2 id="learning-objectives">Learning Objectives</h2>
        <p>By the end of this module, you will be able to:</p>
        <ol>
            <li>Understand the fundamentals of asynchronous programming with CompletableFuture</li>
            <li>Create and chain asynchronous operations</li>
            <li>Handle exceptions in asynchronous code</li>
            <li>Implement timeout and cancellation strategies</li>
            <li>Apply CompletableFuture in common test automation scenarios</li>
        </ol>

        <h2 id="51-introduction-to-asynchronous-programming">5.1 Introduction to Asynchronous Programming</h2>

        <h3 id="synchronous-vs-asynchronous-execution">Synchronous vs. Asynchronous Execution</h3>
        <p>In synchronous execution, operations are performed sequentially, with each operation blocking until it completes:</p>
        <pre><code>// Synchronous execution
result1 = operation1();
result2 = operation2(result1);
result3 = operation3(result2);
</code></pre>

        <p>In asynchronous execution, operations can be initiated without waiting for completion:</p>
        <pre><code>// Asynchronous execution
CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -> operation1());
CompletableFuture&lt;String&gt; future2 = future1.thenApplyAsync(result -> operation2(result));
CompletableFuture&lt;String&gt; future3 = future2.thenApplyAsync(result -> operation3(result));
</code></pre>

        <h2 id="52-creating-completablefuture">5.2 Creating CompletableFuture</h2>

        <h3 id="basic-creation-methods">Basic Creation Methods</h3>
        <pre><code>@Test
public void testCompletableFutureCreation() {
    // Create completed future
    CompletableFuture&lt;String&gt; completed = CompletableFuture.completedFuture("Hello");
    assertEquals("Hello", completed.join());
    
    // Create future with supplier
    CompletableFuture&lt;String&gt; supplied = CompletableFuture.supplyAsync(() -> {
        // Simulate API call
        return "API Response";
    });
    
    // Create future with runnable (no return value)
    CompletableFuture&lt;Void&gt; runnable = CompletableFuture.runAsync(() -> {
        System.out.println("Background task completed");
    });
}
</code></pre>

        <h3 id="test-automation-example">Test Automation Example</h3>
        <pre><code>public class AsyncTestOperations {
    
    @Test
    public void testParallelApiCalls() {
        // Execute multiple API calls in parallel
        CompletableFuture&lt;String&gt; userFuture = CompletableFuture.supplyAsync(() -> 
            callUserApi("user123"));
        
        CompletableFuture&lt;String&gt; orderFuture = CompletableFuture.supplyAsync(() -> 
            callOrderApi("order456"));
        
        CompletableFuture&lt;String&gt; inventoryFuture = CompletableFuture.supplyAsync(() -> 
            callInventoryApi("item789"));
        
        // Wait for all to complete
        CompletableFuture&lt;Void&gt; allFutures = CompletableFuture.allOf(
            userFuture, orderFuture, inventoryFuture);
        
        allFutures.join(); // Wait for completion
        
        // Verify results
        assertNotNull(userFuture.join());
        assertNotNull(orderFuture.join());
        assertNotNull(inventoryFuture.join());
    }
}
</code></pre>

        <h2 id="53-chaining-operations">5.3 Chaining Operations</h2>

        <h3 id="transformation-methods">Transformation Methods</h3>
        <pre><code>@Test
public void testChainingOperations() {
    CompletableFuture&lt;String&gt; result = CompletableFuture
        .supplyAsync(() -> "user123")
        .thenApply(userId -> fetchUserData(userId))
        .thenApply(userData -> processUserData(userData))
        .thenApply(processedData -> generateReport(processedData));
    
    String finalResult = result.join();
    assertNotNull(finalResult);
}

@Test
public void testAsyncChaining() {
    CompletableFuture&lt;String&gt; result = CompletableFuture
        .supplyAsync(() -> "user123")
        .thenApplyAsync(userId -> fetchUserData(userId))
        .thenApplyAsync(userData -> processUserData(userData))
        .thenApplyAsync(processedData -> generateReport(processedData));
    
    String finalResult = result.join();
    assertNotNull(finalResult);
}
</code></pre>

        <h2 id="54-combining-futures">5.4 Combining Futures</h2>

        <h3 id="combining-two-futures">Combining Two Futures</h3>
        <pre><code>@Test
public void testCombiningFutures() {
    CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -> "Hello");
    CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -> "World");
    
    // Combine two futures
    CompletableFuture&lt;String&gt; combined = future1.thenCombine(future2, 
        (result1, result2) -> result1 + " " + result2);
    
    assertEquals("Hello World", combined.join());
}

@Test
public void testCombiningMultipleFutures() {
    List&lt;CompletableFuture&lt;String&gt;&gt; futures = Arrays.asList(
        CompletableFuture.supplyAsync(() -> callService1()),
        CompletableFuture.supplyAsync(() -> callService2()),
        CompletableFuture.supplyAsync(() -> callService3())
    );
    
    // Wait for all to complete and collect results
    CompletableFuture&lt;List&lt;String&gt;&gt; allResults = CompletableFuture
        .allOf(futures.toArray(new CompletableFuture[0]))
        .thenApply(v -> futures.stream()
            .map(CompletableFuture::join)
            .collect(Collectors.toList()));
    
    List&lt;String&gt; results = allResults.join();
    assertEquals(3, results.size());
}
</code></pre>

        <h2 id="55-exception-handling">5.5 Exception Handling</h2>

        <h3 id="handling-exceptions">Handling Exceptions</h3>
        <pre><code>@Test
public void testExceptionHandling() {
    CompletableFuture&lt;String&gt; future = CompletableFuture
        .supplyAsync(() -> {
            if (Math.random() > 0.5) {
                throw new RuntimeException("Random failure");
            }
            return "Success";
        })
        .exceptionally(throwable -> {
            System.err.println("Exception occurred: " + throwable.getMessage());
            return "Default value";
        });
    
    String result = future.join();
    assertNotNull(result);
}

@Test
public void testExceptionHandlingWithHandle() {
    CompletableFuture&lt;String&gt; future = CompletableFuture
        .supplyAsync(() -> {
            throw new RuntimeException("Test exception");
        })
        .handle((result, throwable) -> {
            if (throwable != null) {
                return "Error: " + throwable.getMessage();
            }
            return result;
        });
    
    String result = future.join();
    assertTrue(result.startsWith("Error:"));
}
</code></pre>

        <h2 id="56-timeouts-and-cancellation">5.6 Timeouts and Cancellation</h2>

        <h3 id="implementing-timeouts">Implementing Timeouts</h3>
        <pre><code>@Test
public void testTimeout() {
    CompletableFuture&lt;String&gt; future = CompletableFuture
        .supplyAsync(() -> {
            try {
                Thread.sleep(5000); // Simulate long operation
                return "Completed";
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        })
        .orTimeout(2, TimeUnit.SECONDS)
        .exceptionally(throwable -> {
            if (throwable instanceof TimeoutException) {
                return "Operation timed out";
            }
            return "Error occurred";
        });
    
    String result = future.join();
    assertEquals("Operation timed out", result);
}

@Test
public void testCancellation() {
    CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -> {
        try {
            Thread.sleep(5000);
            return "Completed";
        } catch (InterruptedException e) {
            return "Interrupted";
        }
    });
    
    // Cancel after 1 second
    ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
    scheduler.schedule(() -> future.cancel(true), 1, TimeUnit.SECONDS);
    
    assertTrue(future.isCancelled());
}
</code></pre>

        <h2 id="57-practical-test-automation-scenarios">5.7 Practical Test Automation Scenarios</h2>

        <h3 id="parallel-ui-testing">Parallel UI Testing</h3>
        <pre><code>public class ParallelUITests {
    
    @Test
    public void testParallelBrowserOperations() {
        List&lt;String&gt; urls = Arrays.asList(
            "https://example1.com",
            "https://example2.com", 
            "https://example3.com"
        );
        
        List&lt;CompletableFuture&lt;String&gt;&gt; futures = urls.stream()
            .map(url -> CompletableFuture.supplyAsync(() -> testUrl(url)))
            .collect(Collectors.toList());
        
        CompletableFuture&lt;Void&gt; allTests = CompletableFuture.allOf(
            futures.toArray(new CompletableFuture[0]));
        
        allTests.join();
        
        // Verify all tests passed
        futures.forEach(future -> {
            String result = future.join();
            assertEquals("PASSED", result);
        });
    }
    
    private String testUrl(String url) {
        // Simulate browser test
        WebDriver driver = new ChromeDriver();
        try {
            driver.get(url);
            // Perform test operations
            return "PASSED";
        } finally {
            driver.quit();
        }
    }
}
</code></pre>

        <h3 id="asynchronous-api-testing">Asynchronous API Testing</h3>
        <pre><code>public class AsyncApiTests {
    
    @Test
    public void testAsyncApiWorkflow() {
        CompletableFuture&lt;String&gt; workflow = CompletableFuture
            .supplyAsync(() -> createUser())
            .thenCompose(userId -> 
                CompletableFuture.supplyAsync(() -> createOrder(userId)))
            .thenCompose(orderId -> 
                CompletableFuture.supplyAsync(() -> processPayment(orderId)))
            .thenCompose(paymentId -> 
                CompletableFuture.supplyAsync(() -> sendConfirmation(paymentId)))
            .exceptionally(throwable -> {
                System.err.println("Workflow failed: " + throwable.getMessage());
                return "FAILED";
            });
        
        String result = workflow.join();
        assertNotEquals("FAILED", result);
    }
    
    @Test
    public void testApiLoadTesting() {
        int numberOfRequests = 100;
        List&lt;CompletableFuture&lt;Long&gt;&gt; futures = IntStream.range(0, numberOfRequests)
            .mapToObj(i -> CompletableFuture.supplyAsync(() -> {
                long startTime = System.currentTimeMillis();
                callApi();
                return System.currentTimeMillis() - startTime;
            }))
            .collect(Collectors.toList());
        
        CompletableFuture&lt;Void&gt; allRequests = CompletableFuture.allOf(
            futures.toArray(new CompletableFuture[0]));
        
        allRequests.join();
        
        // Calculate average response time
        double averageTime = futures.stream()
            .mapToLong(CompletableFuture::join)
            .average()
            .orElse(0.0);
        
        assertTrue("Average response time should be under 1000ms", 
                   averageTime < 1000);
    }
}
</code></pre>

        <h2 id="58-best-practices">5.8 Best Practices</h2>

        <h3 id="thread-pool-management">Thread Pool Management</h3>
        <pre><code>public class AsyncTestManager {
    private final ExecutorService customExecutor = 
        Executors.newFixedThreadPool(10);
    
    @Test
    public void testWithCustomExecutor() {
        CompletableFuture&lt;String&gt; future = CompletableFuture
            .supplyAsync(() -> performOperation(), customExecutor)
            .thenApplyAsync(result -> processResult(result), customExecutor);
        
        String result = future.join();
        assertNotNull(result);
    }
    
    @AfterEach
    public void cleanup() {
        customExecutor.shutdown();
    }
}
</code></pre>

        <h3 id="error-handling-strategies">Error Handling Strategies</h3>
        <pre><code>public class RobustAsyncTesting {
    
    @Test
    public void testWithRetry() {
        CompletableFuture&lt;String&gt; future = retryAsync(() -> 
            unreliableOperation(), 3);
        
        String result = future.join();
        assertNotNull(result);
    }
    
    private CompletableFuture&lt;String&gt; retryAsync(
            Supplier&lt;String&gt; operation, int maxRetries) {
        return CompletableFuture.supplyAsync(operation)
            .exceptionally(throwable -> {
                if (maxRetries > 0) {
                    return retryAsync(operation, maxRetries - 1).join();
                }
                throw new RuntimeException("Max retries exceeded", throwable);
            });
    }
}
</code></pre>

        <div class="module-navigation">
            <a href="Module_4__Optional_Class_for_Null_Handling.html" class="nav-btn prev-btn">
                <i class="fas fa-chevron-left"></i> Previous: Optional Class for Null Handling
            </a>
            <a href="Module_6__Reflection_API_for_Dynamic_Test_Frameworks.html" class="nav-btn next-btn">
                Next: Reflection API for Dynamic Test Frameworks <i class="fas fa-chevron-right"></i>
            </a>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <script src="/js/courses/mermaid_loader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/highlight.min.js"></script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            // Initialize Mermaid for diagram rendering
            if (typeof mermaid !== 'undefined') {
        mermaid.initialize({
            startOnLoad: true,
            theme: 'dark',
            securityLevel: 'loose',
            themeVariables: {
                primaryColor: '#3498db',
                primaryTextColor: '#fff',
                primaryBorderColor: '#1f77b4',
                lineColor: '#f8f9fa',
                secondaryColor: '#6c757d',
                tertiaryColor: '#2c3e50',
                background: '#1e1e2e',
                mainBkg: '#2c3e50',
                nodeBorder: '#3498db',
                clusterBkg: 'rgba(52, 152, 219, 0.2)',
                clusterBorder: '#3498db',
                titleColor: '#3498db'
            }
        });
        
        // Ensure diagram renders after page load
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.init();
        });
            }

            // Initialize syntax highlighting
            if (typeof hljs !== 'undefined') {
                hljs.highlightAll();
            }
        });
    </script>
</body>
</html>

