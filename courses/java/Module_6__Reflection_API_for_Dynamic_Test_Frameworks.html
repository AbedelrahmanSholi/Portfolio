<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Security Meta Tags -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://unpkg.com; style-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com https://cdnjs.cloudflare.com; img-src 'self' data: https:; connect-src 'self'; frame-ancestors 'none'; base-uri 'self'; form-action 'self';">
    <meta http-equiv="X-Frame-Options" content="DENY">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta http-equiv="Referrer-Policy" content="strict-origin-when-cross-origin">
    <meta http-equiv="Permissions-Policy" content="geolocation=(), microphone=(), camera=(), payment=(), usb=(), magnetometer=(), gyroscope=(), speaker=()">

    <link rel="stylesheet" href="../../css/courses/comprehensive_course_styling.css">
    <link rel="stylesheet" href="../../css/optimized/main.min.css">
    <link rel="stylesheet" href="../../css/optimized/courses.min.css">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 6: Reflection API for Dynamic Test Frameworks</title>
    <!-- Base styles -->
    <link href="/css/general_root.css" rel="stylesheet" />
    <link href="/css/background_effect.css" rel="stylesheet" />
    
    <!-- Consolidated hover and z-index styles - loaded early to establish hierarchy -->
    <link href="/css/z_index_system.css" rel="stylesheet" />
    <link href="/css/hover_fix_comprehensive.css" rel="stylesheet" />
    <link href="/css/tooltip_hover.css" rel="stylesheet" />
    
    <!-- Component styles -->
    <link href="/css/slider.css" rel="stylesheet" />
    <link href="/css/enhanced_components.css" rel="stylesheet" />
    <link href="/css/skills_alternative.css" rel="stylesheet" />
    <link href="/css/timeline.css" rel="stylesheet" />
    <link href="/css/project_showcase_fixed.css" rel="stylesheet" />
    <link href="/css/technical_skills_fixed.css" rel="stylesheet" />
    
    <!-- Fixes and enhancements -->
    <link href="/css/mobile_responsive.css" rel="stylesheet" />
    <link href="/css/design_fixes.css" rel="stylesheet" />
    <link href="/css/skills_icons_fix.css" rel="stylesheet" />
    <link href="/css/layout_fixes.css" rel="stylesheet" />
    <link href="/css/contact_fix.css" rel="stylesheet" />
    <link href="/css/final_fixes.css" rel="stylesheet" />
    
    <!-- External resources -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css" integrity="sha512-1ycn6IcaQQ40/MKBW2W4Rhis/DbILU74C1vSrLJxCq57o941Ym01SwNsOMqvEBFlcgUa6xLiPY/NS5R+E6ztJQ==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    
    <!-- Courses section styles -->
    <link href="/css/courses/courses.css" rel="stylesheet" />
    <link href="/css/courses/enhanced_course_styling.css" rel="stylesheet" />
    
    <!-- Syntax highlighting for code blocks -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/styles/atom-one-dark.min.css">

    <script src="../../js/courses/diagram_loader.js"></script></head>

<body>
    <div class="course-content-wrapper">
        <div class="module-navigation">
            <a href="Module_5__CompletableFuture_for_Asynchronous_Operations.html" class="nav-btn prev-btn">
                <i class="fas fa-chevron-left"></i> Previous: CompletableFuture for Asynchronous Operations
            </a>
            <a href="exercises.html" class="nav-btn next-btn">
                Next: Practical Exercises <i class="fas fa-chevron-right"></i>
            </a>
        </div>

        <h1 id="module-6-reflection-api-for-dynamic-test-frameworks">Module 6: Reflection API for Dynamic Test Frameworks</h1>

        <h2 id="overview">Overview</h2>
        <p>The Java Reflection API provides the ability to inspect and manipulate classes, methods, fields, and other components at runtime. In test automation, reflection is particularly powerful for creating dynamic test frameworks, data-driven testing, and building flexible test utilities that can adapt to different scenarios without code changes.</p>

        <h2 id="learning-objectives">Learning Objectives</h2>
        <p>By the end of this module, you will be able to:</p>
        <ol>
            <li>Understand the fundamentals of Java Reflection API</li>
            <li>Dynamically inspect and manipulate classes and objects</li>
            <li>Create flexible test frameworks using reflection</li>
            <li>Implement data-driven testing with reflection</li>
            <li>Build annotation-based test utilities</li>
            <li>Handle reflection exceptions and performance considerations</li>
        </ol>

        <h2 id="61-introduction-to-reflection">6.1 Introduction to Reflection</h2>

        <h3 id="what-is-reflection">What is Reflection?</h3>
        <p>Reflection is the ability of a program to examine and modify its own structure and behavior at runtime. It allows you to:</p>
        <ul>
            <li>Inspect classes, interfaces, fields, and methods</li>
            <li>Create instances of classes dynamically</li>
            <li>Invoke methods and access fields at runtime</li>
            <li>Work with annotations and generic types</li>
        </ul>

        <h3 id="basic-reflection-example">Basic Reflection Example</h3>
        <pre><code>@Test
public void testBasicReflection() throws Exception {
    // Get class information
    Class&lt;String&gt; stringClass = String.class;
    
    // Get class name
    assertEquals("java.lang.String", stringClass.getName());
    
    // Get methods
    Method[] methods = stringClass.getMethods();
    assertTrue(methods.length > 0);
    
    // Find specific method
    Method lengthMethod = stringClass.getMethod("length");
    assertNotNull(lengthMethod);
    
    // Invoke method
    String testString = "Hello World";
    int length = (Integer) lengthMethod.invoke(testString);
    assertEquals(11, length);
}
</code></pre>

        <h2 id="62-working-with-classes">6.2 Working with Classes</h2>

        <h3 id="obtaining-class-objects">Obtaining Class Objects</h3>
        <pre><code>@Test
public void testObtainingClasses() throws Exception {
    // Method 1: Using .class literal
    Class&lt;String&gt; stringClass1 = String.class;
    
    // Method 2: Using Class.forName()
    Class&lt;?&gt; stringClass2 = Class.forName("java.lang.String");
    
    // Method 3: Using getClass() on instance
    String str = "test";
    Class&lt;?&gt; stringClass3 = str.getClass();
    
    // All should be the same
    assertEquals(stringClass1, stringClass2);
    assertEquals(stringClass2, stringClass3);
}
</code></pre>

        <h3 id="inspecting-class-information">Inspecting Class Information</h3>
        <pre><code>public class TestClassInspector {
    
    @Test
    public void testClassInspection() {
        Class&lt;ArrayList&gt; listClass = ArrayList.class;
        
        // Get package information
        Package pkg = listClass.getPackage();
        assertEquals("java.util", pkg.getName());
        
        // Get superclass
        Class&lt;?&gt; superClass = listClass.getSuperclass();
        assertEquals("java.util.AbstractList", superClass.getName());
        
        // Get interfaces
        Class&lt;?&gt;[] interfaces = listClass.getInterfaces();
        assertTrue(interfaces.length > 0);
        
        // Check if it implements specific interface
        assertTrue(List.class.isAssignableFrom(listClass));
    }
    
    @Test
    public void testModifiers() {
        Class&lt;String&gt; stringClass = String.class;
        
        int modifiers = stringClass.getModifiers();
        
        assertTrue(Modifier.isPublic(modifiers));
        assertTrue(Modifier.isFinal(modifiers));
        assertFalse(Modifier.isAbstract(modifiers));
    }
}
</code></pre>

        <h2 id="63-working-with-fields">6.3 Working with Fields</h2>

        <h3 id="accessing-and-modifying-fields">Accessing and Modifying Fields</h3>
        <pre><code>public class TestUser {
    private String name;
    public int age;
    private static String defaultRole = "user";
    
    public TestUser(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    // Getters and setters...
}

@Test
public void testFieldAccess() throws Exception {
    TestUser user = new TestUser("John", 25);
    Class&lt;TestUser&gt; userClass = TestUser.class;
    
    // Access public field
    Field ageField = userClass.getField("age");
    assertEquals(25, ageField.get(user));
    
    // Modify public field
    ageField.set(user, 30);
    assertEquals(30, ageField.get(user));
    
    // Access private field
    Field nameField = userClass.getDeclaredField("name");
    nameField.setAccessible(true); // Make accessible
    assertEquals("John", nameField.get(user));
    
    // Modify private field
    nameField.set(user, "Jane");
    assertEquals("Jane", nameField.get(user));
}

@Test
public void testStaticFieldAccess() throws Exception {
    Class&lt;TestUser&gt; userClass = TestUser.class;
    
    // Access static field
    Field roleField = userClass.getDeclaredField("defaultRole");
    roleField.setAccessible(true);
    assertEquals("user", roleField.get(null)); // null for static fields
    
    // Modify static field
    roleField.set(null, "admin");
    assertEquals("admin", roleField.get(null));
}
</code></pre>

        <h2 id="64-working-with-methods">6.4 Working with Methods</h2>

        <h3 id="invoking-methods-dynamically">Invoking Methods Dynamically</h3>
        <pre><code>public class Calculator {
    public int add(int a, int b) {
        return a + b;
    }
    
    public double multiply(double a, double b) {
        return a * b;
    }
    
    private String formatResult(double result) {
        return String.format("%.2f", result);
    }
}

@Test
public void testMethodInvocation() throws Exception {
    Calculator calc = new Calculator();
    Class&lt;Calculator&gt; calcClass = Calculator.class;
    
    // Invoke public method
    Method addMethod = calcClass.getMethod("add", int.class, int.class);
    int result = (Integer) addMethod.invoke(calc, 5, 3);
    assertEquals(8, result);
    
    // Invoke method with different parameter types
    Method multiplyMethod = calcClass.getMethod("multiply", double.class, double.class);
    double multiplyResult = (Double) multiplyMethod.invoke(calc, 2.5, 4.0);
    assertEquals(10.0, multiplyResult, 0.001);
    
    // Invoke private method
    Method formatMethod = calcClass.getDeclaredMethod("formatResult", double.class);
    formatMethod.setAccessible(true);
    String formatted = (String) formatMethod.invoke(calc, 10.567);
    assertEquals("10.57", formatted);
}
</code></pre>

        <h2 id="65-working-with-constructors">6.5 Working with Constructors</h2>

        <h3 id="dynamic-object-creation">Dynamic Object Creation</h3>
        <pre><code>@Test
public void testConstructorInvocation() throws Exception {
    Class&lt;TestUser&gt; userClass = TestUser.class;
    
    // Get constructor
    Constructor&lt;TestUser&gt; constructor = userClass.getConstructor(String.class, int.class);
    
    // Create instance
    TestUser user = constructor.newInstance("Alice", 28);
    assertNotNull(user);
    
    // Verify the object was created correctly
    Field nameField = userClass.getDeclaredField("name");
    nameField.setAccessible(true);
    assertEquals("Alice", nameField.get(user));
    
    Field ageField = userClass.getField("age");
    assertEquals(28, ageField.get(user));
}

@Test
public void testDefaultConstructor() throws Exception {
    Class&lt;ArrayList&gt; listClass = ArrayList.class;
    
    // Create instance using default constructor
    Constructor&lt;ArrayList&gt; constructor = listClass.getConstructor();
    ArrayList&lt;String&gt; list = constructor.newInstance();
    
    assertNotNull(list);
    assertTrue(list.isEmpty());
}
</code></pre>

        <h2 id="66-working-with-annotations">6.6 Working with Annotations</h2>

        <h3 id="creating-custom-annotations">Creating Custom Annotations</h3>
        <pre><code>@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD, ElementType.TYPE})
public @interface TestInfo {
    String description() default "";
    String author() default "";
    int priority() default 1;
}

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface DataProvider {
    String value() default "";
}

public class AnnotatedTestClass {
    
    @TestInfo(description = "Tests user login functionality", author = "John", priority = 1)
    @Test
    public void testLogin() {
        // Test implementation
    }
    
    @TestInfo(description = "Tests user registration", author = "Jane", priority = 2)
    @Test
    public void testRegistration() {
        // Test implementation
    }
    
    @DataProvider("loginData")
    public Object[][] getLoginData() {
        return new Object[][]{
            {"user1", "pass1"},
            {"user2", "pass2"}
        };
    }
}
</code></pre>

        <h3 id="processing-annotations">Processing Annotations</h3>
        <pre><code>@Test
public void testAnnotationProcessing() throws Exception {
    Class&lt;AnnotatedTestClass&gt; testClass = AnnotatedTestClass.class;
    
    // Get all methods
    Method[] methods = testClass.getDeclaredMethods();
    
    for (Method method : methods) {
        // Check if method has TestInfo annotation
        if (method.isAnnotationPresent(TestInfo.class)) {
            TestInfo testInfo = method.getAnnotation(TestInfo.class);
            
            System.out.println("Method: " + method.getName());
            System.out.println("Description: " + testInfo.description());
            System.out.println("Author: " + testInfo.author());
            System.out.println("Priority: " + testInfo.priority());
        }
        
        // Check for DataProvider annotation
        if (method.isAnnotationPresent(DataProvider.class)) {
            DataProvider dataProvider = method.getAnnotation(DataProvider.class);
            System.out.println("Data Provider: " + dataProvider.value());
        }
    }
}
</code></pre>

        <h2 id="67-building-dynamic-test-framework">6.7 Building Dynamic Test Framework</h2>

        <h3 id="test-runner-with-reflection">Test Runner with Reflection</h3>
        <pre><code>public class ReflectionTestRunner {
    
    public void runTests(Class&lt;?&gt; testClass) throws Exception {
        Object testInstance = testClass.newInstance();
        Method[] methods = testClass.getDeclaredMethods();
        
        // Run setup methods first
        runMethodsWithAnnotation(testInstance, methods, "BeforeEach");
        
        // Run test methods
        for (Method method : methods) {
            if (method.isAnnotationPresent(Test.class)) {
                runSingleTest(testInstance, method);
            }
        }
        
        // Run cleanup methods
        runMethodsWithAnnotation(testInstance, methods, "AfterEach");
    }
    
    private void runSingleTest(Object testInstance, Method testMethod) {
        try {
            System.out.println("Running test: " + testMethod.getName());
            
            // Check for TestInfo annotation
            if (testMethod.isAnnotationPresent(TestInfo.class)) {
                TestInfo info = testMethod.getAnnotation(TestInfo.class);
                System.out.println("Priority: " + info.priority());
                System.out.println("Description: " + info.description());
            }
            
            testMethod.invoke(testInstance);
            System.out.println("✓ Test passed: " + testMethod.getName());
            
        } catch (Exception e) {
            System.err.println("✗ Test failed: " + testMethod.getName());
            System.err.println("Error: " + e.getCause().getMessage());
        }
    }
    
    private void runMethodsWithAnnotation(Object testInstance, Method[] methods, 
                                        String annotationName) throws Exception {
        for (Method method : methods) {
            Annotation[] annotations = method.getAnnotations();
            for (Annotation annotation : annotations) {
                if (annotation.annotationType().getSimpleName().equals(annotationName)) {
                    method.invoke(testInstance);
                }
            }
        }
    }
}
</code></pre>

        <h2 id="68-data-driven-testing-with-reflection">6.8 Data-Driven Testing with Reflection</h2>

        <h3 id="dynamic-data-provider">Dynamic Data Provider</h3>
        <pre><code>public class DataDrivenTestRunner {
    
    public void runDataDrivenTest(Class&lt;?&gt; testClass, String testMethodName) 
            throws Exception {
        Object testInstance = testClass.newInstance();
        Method testMethod = testClass.getMethod(testMethodName, String.class, String.class);
        
        // Find data provider method
        Method dataProviderMethod = findDataProviderMethod(testClass, testMethodName);
        
        if (dataProviderMethod != null) {
            Object[][] testData = (Object[][]) dataProviderMethod.invoke(testInstance);
            
            for (int i = 0; i < testData.length; i++) {
                Object[] row = testData[i];
                System.out.println("Running test with data set " + (i + 1));
                
                try {
                    testMethod.invoke(testInstance, row);
                    System.out.println("✓ Test passed with data: " + Arrays.toString(row));
                } catch (Exception e) {
                    System.err.println("✗ Test failed with data: " + Arrays.toString(row));
                    System.err.println("Error: " + e.getCause().getMessage());
                }
            }
        }
    }
    
    private Method findDataProviderMethod(Class&lt;?&gt; testClass, String testMethodName) {
        Method[] methods = testClass.getDeclaredMethods();
        
        for (Method method : methods) {
            if (method.isAnnotationPresent(DataProvider.class)) {
                DataProvider annotation = method.getAnnotation(DataProvider.class);
                if (annotation.value().equals(testMethodName + "Data")) {
                    return method;
                }
            }
        }
        return null;
    }
}
</code></pre>

        <h2 id="69-performance-and-best-practices">6.9 Performance and Best Practices</h2>

        <h3 id="caching-reflection-objects">Caching Reflection Objects</h3>
        <pre><code>public class ReflectionCache {
    private static final Map&lt;String, Method&gt; methodCache = new ConcurrentHashMap&lt;&gt;();
    private static final Map&lt;String, Field&gt; fieldCache = new ConcurrentHashMap&lt;&gt;();
    
    public static Method getCachedMethod(Class&lt;?&gt; clazz, String methodName, 
                                       Class&lt;?&gt;... parameterTypes) throws NoSuchMethodException {
        String key = clazz.getName() + "." + methodName + "(" + 
                    Arrays.toString(parameterTypes) + ")";
        
        return methodCache.computeIfAbsent(key, k -> {
            try {
                return clazz.getMethod(methodName, parameterTypes);
            } catch (NoSuchMethodException e) {
                throw new RuntimeException(e);
            }
        });
    }
    
    public static Field getCachedField(Class&lt;?&gt; clazz, String fieldName) 
            throws NoSuchFieldException {
        String key = clazz.getName() + "." + fieldName;
        
        return fieldCache.computeIfAbsent(key, k -> {
            try {
                Field field = clazz.getDeclaredField(fieldName);
                field.setAccessible(true);
                return field;
            } catch (NoSuchFieldException e) {
                throw new RuntimeException(e);
            }
        });
    }
}
</code></pre>

        <h3 id="exception-handling">Exception Handling</h3>
        <pre><code>public class SafeReflectionUtils {
    
    public static Optional&lt;Object&gt; invokeMethodSafely(Object instance, 
                                                    String methodName, 
                                                    Object... args) {
        try {
            Class&lt;?&gt; clazz = instance.getClass();
            Class&lt;?&gt;[] paramTypes = Arrays.stream(args)
                .map(Object::getClass)
                .toArray(Class[]::new);
            
            Method method = clazz.getMethod(methodName, paramTypes);
            Object result = method.invoke(instance, args);
            return Optional.ofNullable(result);
            
        } catch (Exception e) {
            System.err.println("Failed to invoke method: " + methodName);
            System.err.println("Error: " + e.getMessage());
            return Optional.empty();
        }
    }
    
    public static Optional&lt;Object&gt; getFieldValueSafely(Object instance, 
                                                      String fieldName) {
        try {
            Field field = instance.getClass().getDeclaredField(fieldName);
            field.setAccessible(true);
            Object value = field.get(instance);
            return Optional.ofNullable(value);
            
        } catch (Exception e) {
            System.err.println("Failed to get field value: " + fieldName);
            System.err.println("Error: " + e.getMessage());
            return Optional.empty();
        }
    }
}
</code></pre>

        <div class="module-navigation">
            <a href="Module_5__CompletableFuture_for_Asynchronous_Operations.html" class="nav-btn prev-btn">
                <i class="fas fa-chevron-left"></i> Previous: CompletableFuture for Asynchronous Operations
            </a>
            <a href="exercises.html" class="nav-btn next-btn">
                Next: Practical Exercises <i class="fas fa-chevron-right"></i>
            </a>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <script src="/js/courses/mermaid_loader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/highlight.min.js"></script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            // Initialize Mermaid for diagram rendering
            if (typeof mermaid !== 'undefined') {
        mermaid.initialize({
            startOnLoad: true,
            theme: 'dark',
            securityLevel: 'loose',
            themeVariables: {
                primaryColor: '#3498db',
                primaryTextColor: '#fff',
                primaryBorderColor: '#1f77b4',
                lineColor: '#f8f9fa',
                secondaryColor: '#6c757d',
                tertiaryColor: '#2c3e50',
                background: '#1e1e2e',
                mainBkg: '#2c3e50',
                nodeBorder: '#3498db',
                clusterBkg: 'rgba(52, 152, 219, 0.2)',
                clusterBorder: '#3498db',
                titleColor: '#3498db'
            }
        });
        
        // Ensure diagram renders after page load
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.init();
        });
            }

            // Initialize syntax highlighting
            if (typeof hljs !== 'undefined') {
                hljs.highlightAll();
            }
        });
    </script>
</body>
</html>

